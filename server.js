// server.js
// Chat server (rewritten): server-assisted room key wrapping so any device can decrypt.
// - Each room has a symmetric AES-GCM room key (generated by server at create).
// - Server stores room keys encrypted at-rest with SERVER_MASTER_KEY.
// - Server keeps a long-term ECDH keypair; when a client joins and provides their publicJwk,
//   server derives an ECDH wrapping key (serverPriv + clientPub) and encrypts the room key for that client.
// - Client unwraps and uses the room key to encrypt/decrypt messages with AES-GCM.
// - Other server behavior kept intact (admin endpoints, banlist, etc.)

const express = require('express');
const http = require('http');
const fs = require('fs').promises;
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const bodyParser = require('body-parser');
const { Server } = require('socket.io');
const { webcrypto } = require('crypto'); // Node >= 18
const subtle = webcrypto.subtle;

const PORT = process.env.PORT || 8080;
const DATA_DIR = path.join(__dirname, 'data');
const DATA_PATH = path.join(DATA_DIR, 'rooms.json');
const BAN_PATH = path.join(DATA_DIR, 'banned.json');
const SERVER_KEY_PATH = path.join(DATA_DIR, 'server_key.json');
const PUBLIC_DIR = path.join(__dirname, 'public');

const ADMIN_USER = process.env.ADMIN_USER || 'admin';
const ADMIN_PASS = process.env.ADMIN_PASS || 'password';
const ADMIN_SECRET = process.env.ADMIN_SECRET || 'dev-secret';

const BUILD_ID = Date.now();
console.log('BUILD_ID', BUILD_ID);

// server master symmetric key for at-rest encryption (base64 -> 32 bytes)
const SERVER_MASTER_KEY_B64 = process.env.SERVER_MASTER_KEY || null;
let SERVER_MASTER_KEY = null;
if (SERVER_MASTER_KEY_B64) {
  try {
    const buf = Buffer.from(SERVER_MASTER_KEY_B64, 'base64');
    if (buf.length !== 32) {
      console.warn('SERVER_MASTER_KEY must be base64 32 bytes. Ignoring and will generate ephemeral key.');
    } else {
      SERVER_MASTER_KEY = buf;
    }
  } catch (e) {
    console.warn('Invalid SERVER_MASTER_KEY; will generate ephemeral key.');
  }
}

if (!SERVER_MASTER_KEY) {
  // generate ephemeral key (not persisted). Warning: rooms' keys won't survive restarts.
  console.warn('No valid SERVER_MASTER_KEY found in env. Generating ephemeral master key (not persisted). Set SERVER_MASTER_KEY to persist room keys across restarts.');
  SERVER_MASTER_KEY = require('crypto').randomBytes(32);
}

// in-memory maps
const sessions = new Map(); // socketId -> { username, roomId, lastSeen, isAdmin }
const roomTypers = new Map(); // roomId -> Set(username)
const adminSessions = new Map(); // adminToken -> { createdAt }

// --- helpers: base64 / arraybuffer conversions ---
function bufToB64(buf) { return Buffer.from(buf).toString('base64'); }
function b64ToBuf(b64) { return Buffer.from(b64, 'base64'); }
function abToBuf(ab) { return Buffer.from(new Uint8Array(ab)); }
function bufToAb(buf) { return Uint8Array.from(buf).buffer; }

// --- file read/write helpers ---
async function readJSON(p, fallback = null) {
  try {
    const raw = await fs.readFile(p, 'utf8');
    return JSON.parse(raw);
  } catch (e) {
    if (e.code === 'ENOENT') return fallback;
    console.error('readJSON error', e);
    throw e;
  }
}
async function writeJSONAtomic(p, obj) {
  try {
    await fs.mkdir(path.dirname(p), { recursive: true });
    const tmp = p + '.tmp';
    await fs.writeFile(tmp, JSON.stringify(obj, null, 2), 'utf8');
    await fs.rename(tmp, p);
  } catch (e) {
    console.error('writeJSONAtomic error', e);
    throw e;
  }
}

async function readData() {
  const data = await readJSON(DATA_PATH, { rooms: [] });
  return data;
}
async function writeData(data) {
  await writeJSONAtomic(DATA_PATH, data);
}
async function readBanList() {
  return await readJSON(BAN_PATH, []);
}
async function writeBanList(list) {
  await writeJSONAtomic(BAN_PATH, list);
}

// find helpers
function findRoomById(data, id) { return data.rooms.find(r => r.id === id) || null; }
function findRoomByToken(data, token) {
  if (!token) return null;
  return data.rooms.find(r => r.inviteToken === token) || null;
}

// --- server ECDH key management ---
// stored server_key.json: { publicJwk: {...}, privateJwk: {...} }
async function ensureServerKeypair() {
  try {
    const json = await readJSON(SERVER_KEY_PATH, null);
    if (json && json.publicJwk && json.privateJwk) {
      return json;
    }
  } catch (e) {
    // fallthrough to generate
  }
  // generate new ECDH P-256 pair
  const kp = await subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey', 'deriveBits']);
  const pub = await subtle.exportKey('jwk', kp.publicKey);
  const priv = await subtle.exportKey('jwk', kp.privateKey);
  const toSave = { publicJwk: pub, privateJwk: priv };
  await writeJSONAtomic(SERVER_KEY_PATH, toSave);
  console.log('Generated new server ECDH keypair and saved to', SERVER_KEY_PATH);
  return toSave;
}

// --- at-rest encryption for room symmetric keys with SERVER_MASTER_KEY (AES-GCM) ---
async function importMasterKey() {
  return subtle.importKey('raw', SERVER_MASTER_KEY, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']);
}
async function encryptRoomKeyAtRest(roomKeyBuf) {
  const masterKey = await importMasterKey();
  const iv = webcrypto.getRandomValues(new Uint8Array(12));
  const ct = await subtle.encrypt({ name: 'AES-GCM', iv }, masterKey, roomKeyBuf);
  return { ciphertext: bufToB64(abToBuf(ct)), iv: bufToB64(iv) };
}
async function decryptRoomKeyAtRest(obj) {
  // obj: { ciphertext: base64, iv: base64 }
  if (!obj || !obj.ciphertext || !obj.iv) return null;
  const masterKey = await importMasterKey();
  const ct = b64ToBuf(obj.ciphertext);
  const iv = b64ToBuf(obj.iv);
  const plain = await subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, masterKey, bufToAb(ct));
  return abToBuf(plain); // Buffer
}

// --- derive wrapping key (serverPriv + clientPub) and AES-GCM encrypt provided roomKeyBuf ---
async function wrapRoomKeyForClient(serverKeypairJwk, clientPublicJwk, roomKeyBuf) {
  // import client public
  const clientPub = await subtle.importKey('jwk', clientPublicJwk, { name: 'ECDH', namedCurve: 'P-256' }, false, []);
  const serverPriv = await subtle.importKey('jwk', serverKeypairJwk.privateJwk, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
  const derived = await subtle.deriveKey({ name: 'ECDH', public: clientPub }, serverPriv, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']);
  const iv = webcrypto.getRandomValues(new Uint8Array(12));
  const wrapped = await subtle.encrypt({ name: 'AES-GCM', iv }, derived, roomKeyBuf);
  return { wrappedKey: bufToB64(abToBuf(wrapped)), iv: bufToB64(iv) };
}

// --- helper: create a new random room symmetric key (32 bytes) ---
function generateRoomSymKeyBuf() { return require('crypto').randomBytes(32); }

// --- presence gather ---
async function gatherPresence(roomId) {
  const data = await readData();
  const room = data.rooms.find(r => r.id === roomId);
  if (!room) return { members: [] };
  const members = Object.keys(room.membersPublic || {});
  const result = members.map(username => {
    let online = false;
    let lastSeen = null;
    for (const [sid, s] of sessions) {
      if (s.username === username && s.roomId === roomId) {
        online = true;
        lastSeen = s.lastSeen || Date.now();
        break;
      }
    }
    return { username, online, lastSeen: online ? null : lastSeen };
  });
  return { members: result };
}

/* ---------- express + static ---------- */
const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*', methods: ['GET', 'POST'] } });

app.use((req, res, next) => {
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  res.setHeader('Surrogate-Control', 'no-store');
  next();
});
app.use(express.static(PUBLIC_DIR, { index: false, etag: false, lastModified: false }));
app.use(bodyParser.json({ limit: '5mb' }));

/* index injection same as before */
app.get(['/', '/index.html'], async (req, res) => {
  try {
    const htmlPath = path.join(PUBLIC_DIR, 'index.html');
    let html = await fs.readFile(htmlPath, 'utf8');

    const bootstrap = `
<script>
(function(){
  try {
    const SERVER_BUILD = ${BUILD_ID};
    const KEY = 'APP_BUILD_ID';
    const prev = localStorage.getItem(KEY);
    if (prev && Number(prev) !== SERVER_BUILD) {
      if ('serviceWorker' in navigator) navigator.serviceWorker.getRegistrations().then(regs=>regs.forEach(r=>r.unregister())).catch(()=>{});
      if (window.caches && caches.keys) caches.keys().then(keys=>Promise.all(keys.map(k=>caches.delete(k)))).catch(()=>{});
      localStorage.setItem(KEY, String(SERVER_BUILD));
      if (!sessionStorage.getItem('reloaded_for_build')) { sessionStorage.setItem('reloaded_for_build','1'); window.location.reload(true); } else { sessionStorage.removeItem('reloaded_for_build'); }
    } else { localStorage.setItem(KEY, String(SERVER_BUILD)); }
  } catch(e) { console.warn('bootstrap', e); }
})();
</script>
`;

    const socketUrl = `/socket.io/socket.io.js?b=${BUILD_ID}`;
    const mainUrl = `/mainv6.js?b=${BUILD_ID}`;
    const inject = `${bootstrap}\n<link rel="stylesheet" href="/styles.css?b=${BUILD_ID}">\n<script src="${socketUrl}"></script>\n<script src="${mainUrl}" defer></script>\n`;
    html = html.includes('<!-- INJECT_SCRIPTS -->') ? html.replace('<!-- INJECT_SCRIPTS -->', inject) : html.replace('</body>', `${inject}</body>`);
    res.type('html').send(html);
  } catch (e) {
    console.error('serve index error', e);
    res.status(500).send('index read error');
  }
});

app.get('/mainv6.js', async (req, res) => {
  try {
    const jsPath = path.join(PUBLIC_DIR, 'mainv6.js');
    const content = await fs.readFile(jsPath, 'utf8');
    res.set('Content-Type', 'application/javascript; charset=utf-8');
    res.send(content);
  } catch (e) {
    console.error('serve mainv6.js error', e);
    res.status(500).send('// mainv6.js not found');
  }
});

app.get('/admin.html', async (req, res) => {
  try {
    const p = path.join(PUBLIC_DIR, 'admin.html');
    let html = await fs.readFile(p, 'utf8');
    const inject = `<script src="/admin.js?b=${BUILD_ID}" defer></script><link rel="stylesheet" href="/styles.css?b=${BUILD_ID}">`;
    html = html.replace('<!-- INJECT_SCRIPTS -->', inject);
    res.type('html').send(html);
  } catch (e) {
    console.error('serve admin.html error', e);
    res.status(500).send('admin not found');
  }
});

/* ---------- API endpoints (rooms, create) ---------- */

app.get('/_version', (req, res) => res.json({ build: BUILD_ID, started: new Date().toISOString(), pid: process.pid }));

app.get('/api/rooms', async (req, res) => {
  try {
    const data = await readData();
    const rooms = (data.rooms || []).map(r => ({
      id: r.id,
      name: r.name,
      isPrivate: !!r.isPrivate,
      owner: r.owner,
      hasInvite: !!r.inviteToken
    }));
    res.json({ rooms });
  } catch (e) {
    console.error('/api/rooms error', e);
    res.status(500).json({ error: 'server error' });
  }
});

// create room: server generates roomSymKey and stores encrypted at-rest
app.post('/api/rooms', async (req, res) => {
  try {
    const { name, isPrivate, owner, ownerPublicJwk, inviteToken } = req.body || {};
    if (!name || !owner || !ownerPublicJwk) return res.status(400).json({ error: 'name, owner, ownerPublicJwk required' });

    const data = await readData();
    const id = uuidv4();
    let token = null;
    if (isPrivate) {
      if (inviteToken && typeof inviteToken === 'string' && inviteToken.trim().length >= 4 && inviteToken.trim().length <= 64) {
        token = inviteToken.trim();
      } else {
        token = Math.random().toString(36).slice(2, 10);
      }
    }

    // create a random room symmetric key
    const roomSymKeyBuf = generateRoomSymKeyBuf();
    const encryptedAtRest = await encryptRoomKeyAtRest(roomSymKeyBuf); // {ciphertext, iv} base64

    const serverKeypair = await ensureServerKeypair();

    const room = {
      id,
      name,
      isPrivate: !!isPrivate,
      owner,
      inviteToken: token || null,
      // serverPublicJwk provided so clients can derive shared secret with their privateJwk
      serverPublicJwk: serverKeypair.publicJwk,
      // at-rest encrypted symmetric key (server cannot read without master key)
      encRoomKey: encryptedAtRest,
      // membersPublic holds device-level JWKs per username (each device will register its own publicJwk on join)
      banned: [],
      membersPublic: { [owner]: ownerPublicJwk }, // persist owner so creator not locked out
      history: []
    };

    data.rooms.push(room);
    await writeData(data);
    return res.json({ roomId: id, inviteToken: token || null });
  } catch (e) {
    console.error('POST /api/rooms error', e);
    res.status(500).json({ error: 'server error' });
  }
});

/* ---------- admin endpoints (unchanged in behavior) ---------- */

function verifyAdminToken(req) {
  const token = req.get('x-admin-token') || '';
  if (!token) return false;
  return adminSessions.has(token);
}

app.post('/api/admin/login', async (req, res) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ error: 'username & password required' });
    if (username !== ADMIN_USER || password !== ADMIN_PASS) return res.status(403).json({ error: 'unauthorized' });

    const token = uuidv4();
    adminSessions.set(token, { createdAt: Date.now() });
    return res.json({ adminToken: token });
  } catch (e) {
    console.error('admin login error', e);
    res.status(500).json({ error: 'server error' });
  }
});

app.post('/api/admin/logout', (req, res) => {
  try {
    const token = req.get('x-admin-token') || '';
    if (token && adminSessions.has(token)) adminSessions.delete(token);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: 'server error' }); }
});

app.post('/api/admin/sync-chats', async (req, res) => {
  try {
    if (!verifyAdminToken(req) && req.get('x-admin-secret') !== ADMIN_SECRET) return res.status(403).json({ error: 'unauthorized' });
    const { rooms } = req.body || {};
    if (!Array.isArray(rooms)) return res.status(400).json({ error: 'rooms array required' });
    const data = { rooms: rooms.map(r => ({
      id: r.id || uuidv4(),
      name: r.name || 'room',
      isPrivate: !!r.isPrivate,
      owner: r.owner || 'owner',
      inviteToken: r.inviteToken || null,
      serverPublicJwk: r.serverPublicJwk || (await ensureServerKeypair()).publicJwk,
      encRoomKey: r.encRoomKey || null,
      banned: r.banned || [],
      membersPublic: r.membersPublic || {},
      history: r.history || []
    }))};
    await writeData(data);
    return res.json({ ok: true, count: data.rooms.length });
  } catch (e) {
    console.error('admin sync error', e);
    res.status(500).json({ error: 'server error' });
  }
});

app.post('/api/admin/delete-room', async (req, res) => {
  try {
    if (!verifyAdminToken(req) && req.get('x-admin-secret') !== ADMIN_SECRET) return res.status(403).json({ error: 'unauthorized' });
    const { roomId } = req.body || {};
    if (!roomId) return res.status(400).json({ error: 'roomId required' });
    const data = await readData();
    const idx = data.rooms.findIndex(r => r.id === roomId);
    if (idx === -1) return res.status(404).json({ error: 'room not found' });
    data.rooms.splice(idx, 1);
    await writeData(data);
    io.to(roomId).emit('system:notice', { text: 'This room has been deleted by an admin.' });
    return res.json({ ok: true });
  } catch (e) {
    console.error('admin delete-room error', e);
    res.status(500).json({ error: 'server error' });
  }
});

app.post('/api/admin/upload-banlist', async (req, res) => {
  try {
    if (!verifyAdminToken(req) && req.get('x-admin-secret') !== ADMIN_SECRET) return res.status(403).json({ error: 'unauthorized' });
    const { banned } = req.body || {};
    if (!Array.isArray(banned)) return res.status(400).json({ error: 'banned array required' });
    await writeBanList(banned);
    return res.json({ ok: true, count: banned.length });
  } catch (e) {
    console.error('upload banlist error', e);
    res.status(500).json({ error: 'server error' });
  }
});

app.get('/api/admin/banlist', async (req, res) => {
  try {
    if (!verifyAdminToken(req) && req.get('x-admin-secret') !== ADMIN_SECRET) return res.status(403).json({ error: 'unauthorized' });
    const list = await readBanList();
    res.json({ banned: list });
  } catch (e) {
    console.error('get banlist error', e);
    res.status(500).json({ error: 'server error' });
  }
});

app.get('/api/admin/rooms', async (req, res) => {
  try {
    if (!verifyAdminToken(req) && req.get('x-admin-secret') !== ADMIN_SECRET) return res.status(403).json({ error: 'unauthorized' });
    const data = await readData();
    res.json({ rooms: data.rooms || [] });
  } catch (e) {
    console.error('admin rooms error', e);
    res.status(500).json({ error: 'server error' });
  }
});

/* ---------------- Socket.IO ---------------- */
io.on('connection', (socket) => {
  console.log('socket connected', socket.id);

  function isAdminPayload(payload) {
    if (!payload) return false;
    if (payload.adminSecret && payload.adminSecret === ADMIN_SECRET) return true;
    if (payload.adminToken && adminSessions.has(payload.adminToken)) return true;
    return false;
  }

  socket.on('join', async (payload, ack) => {
    try {
      const { roomIdOrToken, username, publicJwk } = payload || {};
      if (!roomIdOrToken || !username || !publicJwk) {
        if (ack) ack({ ok: false, error: 'roomIdOrToken, username, publicJwk required' });
        return;
      }

      const bannedList = await readBanList();
      if (Array.isArray(bannedList) && bannedList.includes(username)) {
        if (ack) ack({ ok: false, error: 'you are banned' });
        return;
      }

      const data = await readData();
      let room = findRoomById(data, roomIdOrToken);
      let usedToken = false;
      if (!room) {
        room = findRoomByToken(data, roomIdOrToken);
        usedToken = !!room;
      }
      if (!room) {
        if (ack) ack({ ok: false, error: 'room not found' });
        return;
      }

      if (room.isPrivate) {
        const isOwner = username === room.owner;
        if (!usedToken && !isOwner && !(payload && payload._adminBypass === true)) {
          if (ack) ack({ ok: false, error: 'room is private; provide invite token' });
          return;
        }
      }

      if ((room.banned || []).includes(username)) {
        if (ack) ack({ ok: false, error: 'you are banned from this room' });
        return;
      }

      // persist member device publicJwk (per-device) in membersPublic map keyed by username.
      // Note: if the same username has multiple devices, store the latest JWK (device rotates),
      // but we ultimately give wrapped room key on join regardless of previous JWKs.
      room.membersPublic = room.membersPublic || {};
      room.membersPublic[username] = publicJwk;
      await writeData(data);

      // Now prepare wrapped room key for this joining client so they can decrypt history:
      // decrypt the room symmetric key at-rest with SERVER_MASTER_KEY, then wrap with ECDH(serverPriv, clientPub)
      const serverKeypair = await ensureServerKeypair();
      let wrapped = null;
      try {
        const encRoom = room.encRoomKey;
        const roomSymKeyBuf = await decryptRoomKeyAtRest(encRoom); // Buffer
        wrapped = await wrapRoomKeyForClient(serverKeypair, publicJwk, roomSymKeyBuf);
        // wrapped: { wrappedKey: base64, iv: base64 }
      } catch (e) {
        console.error('wrapRoomKeyForClient error', e);
        // proceed without wrapped key (client will fail to decrypt)
      }

      socket.join(room.id);
      sessions.set(socket.id, { username, roomId: room.id, lastSeen: Date.now(), isAdmin: false });

      const presence = await gatherPresence(room.id);
      io.to(room.id).emit('presence:update', presence);
      io.to(room.id).emit('system:notice', { text: `${username} joined.` });
      io.to(room.id).emit('room:meta', { id: room.id, name: room.name, isPrivate: !!room.isPrivate, inviteToken: room.inviteToken || null, owner: room.owner });

      if (ack) ack({
        ok: true,
        data: {
          room: {
            id: room.id,
            name: room.name,
            owner: room.owner,
            isPrivate: !!room.isPrivate,
            inviteToken: room.inviteToken || null,
            // serverPublicJwk so client can derive unwrap key: use server public JWK from persistent keypair
            serverPublicJwk: (await ensureServerKeypair()).publicJwk,
            // wrapped key for this joining device (base64) + iv
            wrappedRoomKey: wrapped ? wrapped.wrappedKey : null,
            wrappedRoomKeyIv: wrapped ? wrapped.iv : null
          },
          history: room.history || []
        }
      });
    } catch (err) {
      console.error('join error', err);
      if (ack) ack({ ok: false, error: 'server error' });
    }
  });

  socket.on('admin:impersonate', async (payload, ack) => {
    try {
      if (!isAdminPayload(payload)) return ack && ack({ ok: false, error: 'unauthorized' });
      const { roomIdOrToken, username, publicJwk } = payload || {};
      if (!roomIdOrToken || !username || !publicJwk) return ack && ack({ ok: false, error: 'roomIdOrToken, username, publicJwk required' });

      const data = await readData();
      let room = findRoomById(data, roomIdOrToken) || findRoomByToken(data, roomIdOrToken);
      if (!room) return ack && ack({ ok: false, error: 'room not found' });

      room.membersPublic = room.membersPublic || {};
      room.membersPublic[username] = publicJwk;
      await writeData(data);

      // wrap room key for this admin-impersonated session as well (same as join)
      const serverKeypair = await ensureServerKeypair();
      let wrapped = null;
      try {
        const roomSymKeyBuf = await decryptRoomKeyAtRest(room.encRoomKey);
        wrapped = await wrapRoomKeyForClient(serverKeypair, publicJwk, roomSymKeyBuf);
      } catch (e) { console.error('wrap for admin impersonate failed', e); }

      socket.join(room.id);
      sessions.set(socket.id, { username, roomId: room.id, lastSeen: Date.now(), isAdmin: true });

      const presence = await gatherPresence(room.id);
      io.to(room.id).emit('presence:update', presence);
      io.to(room.id).emit('system:notice', { text: `${username} (admin) joined.` });
      io.to(room.id).emit('room:meta', { id: room.id, name: room.name, isPrivate: !!room.isPrivate, inviteToken: room.inviteToken || null, owner: room.owner });

      if (ack) ack({ ok: true, data: { room: { id: room.id, name: room.name, owner: room.owner, isPrivate: !!room.isPrivate, inviteToken: room.inviteToken || null, serverPublicJwk: (await ensureServerKeypair()).publicJwk, wrappedRoomKey: wrapped ? wrapped.wrappedKey : null, wrappedRoomKeyIv: wrapped ? wrapped.iv : null }, history: room.history || [] } });
    } catch (err) {
      console.error('admin impersonate err', err);
      if (ack) ack({ ok: false, error: 'server error' });
    }
  });

  // message send persists ciphertext & iv as before (no change)
  socket.on('message:send', async (payload, ack) => {
    try {
      const session = sessions.get(socket.id);
      if (!session) { if (ack) ack({ ok: false, error: 'not in room' }); return; }
      const { roomId, from, ciphertext, iv, ts } = payload || {};
      if (!roomId || !from || !ciphertext || !iv || !ts) { if (ack) ack({ ok: false, error: 'bad payload' }); return; }
      const data = await readData();
      const room = data.rooms.find(r => r.id === roomId);
      if (!room) { if (ack) ack({ ok: false, error: 'room not found' }); return; }
      const message = { id: uuidv4(), from, ciphertext, iv, ts };
      room.history = room.history || [];
      room.history.push(message);
      await writeData(data);
      io.to(roomId).emit('message:new', message);
      if (ack) ack({ ok: true, id: message.id });
    } catch (err) { console.error('message:send error', err); if (ack) ack({ ok: false, error: 'server error' }); }
  });

  socket.on('typing:start', (payload) => {
    try {
      const session = sessions.get(socket.id);
      if (!session) return;
      const { roomId } = payload || {};
      const rid = roomId || session.roomId;
      if (!rid) return;
      let set = roomTypers.get(rid);
      if (!set) { set = new Set(); roomTypers.set(rid, set); }
      set.add(session.username);
      io.to(rid).emit('typing:update', Array.from(set));
    } catch (err) { console.error('typing:start err', err); }
  });

  socket.on('typing:stop', (payload) => {
    try {
      const session = sessions.get(socket.id);
      if (!session) return;
      const { roomId } = payload || {};
      const rid = roomId || session.roomId;
      if (!rid) return;
      const set = roomTypers.get(rid);
      if (!set) return;
      set.delete(session.username);
      io.to(rid).emit('typing:update', Array.from(set));
    } catch (err) { console.error('typing:stop err', err); }
  });

  socket.on('admin:delete', async (payload, ack) => {
    try {
      if (!isAdminPayload(payload)) return ack && ack({ ok: false, error: 'unauthorized' });
      const { roomId, messageId } = payload || {};
      if (!roomId || !messageId) return ack && ack({ ok: false, error: 'roomId and messageId required' });
      const data = await readData();
      const room = data.rooms.find(r => r.id === roomId);
      if (!room) return ack && ack({ ok: false, error: 'room not found' });
      const origLen = room.history.length;
      room.history = room.history.filter(m => m.id !== messageId);
      if (room.history.length === origLen) return ack && ack({ ok: false, error: 'message id not found' });
      await writeData(data);
      io.to(roomId).emit('message:deleted', { id: messageId, byAdmin: true });
      io.to(roomId).emit('system:notice', { text: `A message was removed by an admin.` });
      if (ack) ack({ ok: true });
    } catch (err) { console.error('admin delete error', err); if (ack) ack({ ok: false, error: 'server error' }); }
  });

  socket.on('leave', (payload, ack) => {
    try {
      const s = sessions.get(socket.id);
      if (!s) { if (ack) ack({ ok: true }); return; }
      const roomId = payload && payload.roomId ? payload.roomId : s.roomId;
      if (roomTypers[roomId]) roomTypers[roomId].delete(s.username);
      sessions.delete(socket.id);
      socket.leave(roomId);
      gatherPresence(roomId).then(p => io.to(roomId).emit('presence:update', p)).catch(() => {});
      if (ack) ack({ ok: true });
    } catch (err) { console.error('leave error', err); if (ack) ack({ ok: false, error: 'server error' }); }
  });

  socket.on('disconnect', async () => {
    const s = sessions.get(socket.id);
    if (s) {
      s.lastSeen = Date.now();
      if (roomTypers[s.roomId]) {
        roomTypers[s.roomId].delete(s.username);
        io.to(s.roomId).emit('typing:update', Array.from(roomTypers[s.roomId]));
      }
      try {
        const presence = await gatherPresence(s.roomId);
        io.to(s.roomId).emit('presence:update', presence);
      } catch (e) {}
      sessions.delete(socket.id);
    }
    console.log('socket disconnected', socket.id);
  });
});

/* start server */
server.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT} (build ${BUILD_ID})`);
});
